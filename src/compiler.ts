import type { MarkdownlangProgram, JsonSchema } from "./types.js";

/**
 * Convert a JSON Schema type to a TypeScript type string.
 */
function jsonSchemaTypeToTS(schema: JsonSchema): string {
  if (!schema || !schema.type) return "any";

  switch (schema.type) {
    case "string":
      if (schema.enum) {
        return schema.enum.map((v: any) => JSON.stringify(v)).join(" | ");
      }
      return "string";
    case "integer":
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    case "null":
      return "null";
    case "array": {
      const itemType = schema.items
        ? jsonSchemaTypeToTS(schema.items)
        : "unknown";
      return `${itemType}[]`;
    }
    case "object": {
      if (!schema.properties) return "Record<string, unknown>";
      const props = Object.entries(schema.properties).map(
        ([key, value]: [string, JsonSchema]) => {
          const optional = schema.required?.includes(key) ? "" : "?";
          return `  ${key}${optional}: ${jsonSchemaTypeToTS(value)};`;
        }
      );
      return `{\n${props.join("\n")}\n}`;
    }
    default:
      return "unknown";
  }
}

/**
 * Generate a TypeScript interface declaration from a JSON Schema.
 */
function generateInterface(schema: JsonSchema, name: string): string {
  if (schema.type === "object" && schema.properties) {
    const props = Object.entries(schema.properties).map(
      ([key, value]: [string, JsonSchema]) => {
        const optional = schema.required?.includes(key) ? "" : "?";
        const tsType = jsonSchemaTypeToTS(value);
        const desc = value.description
          ? `  /** ${value.description} */\n`
          : "";
        return `${desc}  ${key}${optional}: ${tsType};`;
      }
    );
    return `export interface ${name} {\n${props.join("\n")}\n}`;
  }
  return `export type ${name} = ${jsonSchemaTypeToTS(schema)};`;
}

/**
 * Escape a string for use inside a JS template literal.
 */
function escapeTemplateLiteral(s: string): string {
  return s.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$/g, "\\$");
}

/**
 * Compile a markdownlang program into TypeScript source code.
 *
 * The generated code:
 *   - Imports OpenAI and dotenv
 *   - Defines Input/Output types from the schemas
 *   - Contains the prompt template
 *   - Exports a `run(input)` function
 *   - Includes a main() that reads input from argv
 */
export function compile(program: MarkdownlangProgram): string {
  const inputInterface = generateInterface(program.input, "Input");
  const outputInterface = generateInterface(program.output, "Output");
  const escapedBody = escapeTemplateLiteral(program.body);
  const escapedDesc = escapeTemplateLiteral(program.description);
  const escapedName = escapeTemplateLiteral(program.name);
  const outputSchemaJson = JSON.stringify(
    prepareSchemaForCompile(program.output),
    null,
    2
  );

  return `/**
 * Auto-generated TypeScript from markdownlang program: ${program.name}
 * ${program.description}
 *
 * Generated by: markdownlang compile
 */
import OpenAI from "openai";
import * as dotenv from "dotenv";

// Load environment variables
dotenv.config({ path: ".env.local" });

// ── Types ──────────────────────────────────────────────────

${inputInterface}

${outputInterface}

// ── Template & Schema ──────────────────────────────────────

const PROMPT_TEMPLATE = \`${escapedBody}\`;

const OUTPUT_SCHEMA = ${outputSchemaJson} as const;

// ── Helpers ────────────────────────────────────────────────

function renderTemplate(template: string, data: Record<string, unknown>): string {
  return template.replace(/\\{\\{\\s*\\.(\\w+)\\s*\\}\\}/g, (_match: string, key: string) => {
    if (key in data) {
      const value = data[key];
      return typeof value === "object" ? JSON.stringify(value) : String(value);
    }
    return _match;
  });
}

// ── Run ────────────────────────────────────────────────────

export async function run(input: Input): Promise<Output> {
  const client = new OpenAI();
  const prompt = renderTemplate(PROMPT_TEMPLATE, input as unknown as Record<string, unknown>);

  const response = await client.chat.completions.create({
    model: "gpt-4o-mini",
    messages: [
      {
        role: "system",
        content: \`You are executing a markdownlang program called "${escapedName}". ${escapedDesc}. Follow the instructions precisely and return the result as JSON matching the required output schema. Be precise and deterministic.\`,
      },
      {
        role: "user",
        content: prompt,
      },
    ],
    response_format: {
      type: "json_schema",
      json_schema: {
        name: "${escapedName}",
        schema: OUTPUT_SCHEMA,
        strict: true,
      },
    },
  });

  const content = response.choices[0].message.content;
  if (!content) {
    throw new Error("No response content from OpenAI");
  }

  return JSON.parse(content) as Output;
}

// ── CLI Entry Point ────────────────────────────────────────

async function main() {
  const inputArg = process.argv[2];
  if (!inputArg) {
    console.error("Usage: npx tsx ${program.name}.ts '<json-input>'");
    console.error('Example: npx tsx ${program.name}.ts \\'{\"start\": 1, \"end\": 15}\\'');
    process.exit(1);
  }

  let input: Input;
  try {
    input = JSON.parse(inputArg);
  } catch {
    console.error("Error: input must be valid JSON");
    process.exit(1);
  }

  const result = await run(input);
  console.log(JSON.stringify(result, null, 2));
}

main().catch((err) => {
  console.error("Error:", err.message ?? err);
  process.exit(1);
});
`;
}

/**
 * Prepare schema for compilation (same as strict mode preparation in runner).
 */
function prepareSchemaForCompile(schema: JsonSchema): JsonSchema {
  if (!schema || typeof schema !== "object") return schema;

  const result: Record<string, any> = {};

  const supportedKeys = new Set([
    "type",
    "properties",
    "required",
    "items",
    "description",
    "enum",
    "const",
    "anyOf",
    "oneOf",
    "additionalProperties",
  ]);

  for (const [key, value] of Object.entries(schema)) {
    if (supportedKeys.has(key)) {
      result[key] = value;
    }
  }

  if (result.type === "object" && result.properties) {
    result.required = Object.keys(result.properties);
    result.additionalProperties = false;

    const newProps: Record<string, any> = {};
    for (const [key, value] of Object.entries(
      result.properties as Record<string, JsonSchema>
    )) {
      newProps[key] = prepareSchemaForCompile(value);
    }
    result.properties = newProps;
  }

  if (result.type === "array" && result.items) {
    result.items = prepareSchemaForCompile(result.items as JsonSchema);
  }

  return result as JsonSchema;
}
